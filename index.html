<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Op Art Generator V3 - Accurate Masking</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #222;
            color: white;
            font-family: sans-serif;
            gap: 20px; /* 요소들 사이 간격 */
        }
        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: #fff; /* 캔버스 기본 배경은 흰색 */
            border: 1px solid #555;
        }
        .controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        input[type="file"] { margin-bottom: 10px; }
        .status { color: #ffcc00; font-size: 0.9em; margin-top: 5px; }
    </style>
</head>
<body>

    <div class="controls">
        <p><b>검은색 오브젝트 / 흰색 또는 투명 배경</b>의 PNG/JPG를 업로드하세요.</p>
        <div id="status-msg" class="status">대기 중...</div>
    </div>

    <script>
        let inputImg; // 사용자가 업로드한 원본 이미지 (p5.Image 객체)
        let maskGraphics; // 마스킹 픽셀 정보를 담을 그래픽 버퍼
        
        // 이미지 그리기 위치와 크기 (캔버스 중앙에 비율 유지)
        let imgDrawX, imgDrawY, imgDrawW, imgDrawH;

        // 조절 변수
        let gridSize = 10;      // 격자 크기 (작을수록 촘촘)
        let bulgeStrength = 1.8; // 왜곡 강도 (클수록 볼록)

        function setup() {
            let cnv = createCanvas(600, 600);
            cnv.parent(document.body);
            noSmooth(); // 픽셀 아트 느낌

            let fileInput = createFileInput(handleFile);
            fileInput.parent(select('.controls'));

            background(255);
            fill(0);
            textAlign(CENTER, CENTER);
            textSize(16);
            text("이미지를 업로드하면\n이 안에 옵아트 패턴이 생성됩니다.", width/2, height/2);
            noLoop(); // 초기에는 그리지 않음
        }

        function draw() {
            background(255); // 캔버스 배경은 항상 흰색
            
            if (inputImg && maskGraphics) {
                // 1. 원본 이미지를 먼저 그림 (마스킹 확인용)
                // draw() 함수 내에서 p5.Image 객체를 직접 그립니다.
                image(inputImg, imgDrawX, imgDrawY, imgDrawW, imgDrawH);
                
                maskGraphics.loadPixels(); // 마스크 픽셀 정보 로드
                
                // 2. 옵아트 패턴 그리기 (마스크 위에)
                for (let y = 0; y < height; y += gridSize) {
                    for (let x = 0; x < width; x += gridSize) {
                        
                        let cx = x + gridSize / 2;
                        let cy = y + gridSize / 2;

                        // [핵심 수정 부분]
                        // 마스킹 픽셀은 'maskGraphics'에서 가져와야 함
                        // 중요한 것은 마스크 그래픽스에 그려진 이미지의 정확한 위치/크기
                        // 캔버스 좌표(cx, cy)를 마스크 그래픽스의 상대 좌표로 변환
                        
                        // 마스크 그래픽스 내의 상대 좌표
                        let maskX = floor(map(cx, 0, width, 0, maskGraphics.width));
                        let maskY = floor(map(cy, 0, height, 0, maskGraphics.height));
                        
                        // 마스크 그래픽스에서 픽셀 색상 가져오기
                        // get() 함수는 캔버스/그래픽스 객체에 대해 사용 가능
                        let c = maskGraphics.get(maskX, maskY);
                        
                        // 투명도와 밝기로 마스킹 판단 (어둡고 투명하지 않은 부분만)
                        let isMaskedArea = alpha(c) > 50 && brightness(c) < 200;

                        if (isMaskedArea) {
                            // === 왜곡 로직 (이전과 동일) ===
                            let distFromCenter = dist(cx, cy, width/2, height/2);
                            let maxDist = width / 1.5;
                            
                            let factor = map(distFromCenter, 0, maxDist, 1, 0);
                            factor = constrain(factor, 0, 1);
                            let distortion = pow(factor, bulgeStrength); 
                            
                            let currentSize = gridSize * distortion; 
                            
                            let colIndex = floor(x / gridSize);
                            let rowIndex = floor(y / gridSize);
                            
                            fill(0); // 검은색 사각형
                            noStroke();
                            
                            if ((colIndex + rowIndex) % 2 == 0) {
                                rectMode(CENTER);
                                if (currentSize > 0.5) { // 너무 작은 사각형은 그리지 않음
                                    rect(cx, cy, currentSize, currentSize);
                                }
                            }
                        }
                    }
                }
                noLoop();
                select('#status-msg').html("생성 완료!");
            }
        }

        function handleFile(file) {
            if (file.type === 'image') {
                select('#status-msg').html("이미지 처리 중...");
                
                loadImage(file.data, (img) => { // loadImage를 사용하여 p5.Image 생성
                    inputImg = img;
                    
                    // [핵심 수정 부분]
                    // maskGraphics 버퍼 초기화 및 이미지 그리기
                    // 캔버스 크기로 마스크 버퍼를 생성하여 정확한 픽셀 매핑을 위함
                    if (maskGraphics) maskGraphics.remove();
                    maskGraphics = createGraphics(width, height); // 캔버스 크기와 동일하게 생성
                    maskGraphics.clear(); // 투명하게 초기화
                    
                    // 원본 이미지를 마스크 그래픽스에 그릴 위치와 크기 계산 (비율 유지)
                    let imgAspect = inputImg.width / inputImg.height;
                    let canvasAspect = width / height;

                    if (imgAspect > canvasAspect) {
                        imgDrawW = width;
                        imgDrawH = width / imgAspect;
                        imgDrawX = 0;
                        imgDrawY = (height - imgDrawH) / 2;
                    } else {
                        imgDrawH = height;
                        imgDrawW = height * imgAspect;
                        imgDrawX = (width - imgDrawW) / 2;
                        imgDrawY = 0;
                    }
                    // 계산된 크기로 maskGraphics에 이미지를 그립니다.
                    maskGraphics.image(inputImg, imgDrawX, imgDrawY, imgDrawW, imgDrawH);
                    
                    loop(); // draw() 함수 다시 실행하여 업데이트
                });
            } else {
                inputImg = null;
                maskGraphics = null;
                select('#status-msg').html("이미지 파일만 업로드 가능합니다.");
                background(255); // 캔버스 초기화
                fill(0);
                text("이미지 파일만 업로드 가능합니다.", width/2, height/2);
                noLoop();
            }
        }
    </script>
</body>
</html>