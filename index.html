<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Op Art Generator - Bulge Effect</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
        }
        canvas {
            box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
            margin-bottom: 20px;
            border: 1px solid #000;
        }
        .ui-container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        p { margin: 0 0 10px 0; color: #333; font-size: 0.9rem;}
        input[type="file"] { display: block; margin: 0 auto; }
    </style>
</head>
<body>

    <div class="ui-container">
        <p><b>단색 PNG(실루엣)</b>를 업로드하세요.</p>
        </div>

    <script>
        let inputImg;
        let processedImg;
        
        // 값 조절 변수 (나중에 슬라이더로 뺄 수 있음)
        let gridSize = 12;      // 격자 크기 (작을수록 촘촘함)
        let bulgeStrength = 1.8; // 왜곡 강도 (클수록 더 볼록함)

        function setup() {
            // 캔버스 생성 (600x600)
            let cnv = createCanvas(600, 600);
            cnv.parent(document.body); // 캔버스를 body에 붙임 (순서 정렬용)
            
            // 안티앨리어싱 끄기 (픽셀 느낌, 선명한 흑백)
            noSmooth(); 

            // 파일 업로드 버튼 생성
            let fileInput = createFileInput(handleFile);
            
            // 버튼을 ui-container 안으로 이동 (스타일링을 위해)
            let container = select('.ui-container');
            fileInput.parent(container);

            // 초기 안내 문구
            background(255);
            fill(0);
            textAlign(CENTER, CENTER);
            textSize(14);
            text("이미지를 업로드하면\n옵아트 패턴이 생성됩니다.", width/2, height/2);
        }

        function draw() {
            // 이미지가 로드되었을 때만 그리기 연산 수행
            if (processedImg) {
                background(255); // 배경: 흰색
                
                // 이미지 픽셀 데이터 로드
                processedImg.loadPixels();
                
                // 그리드 루프
                for (let y = 0; y < height; y += gridSize) {
                    for (let x = 0; x < width; x += gridSize) {
                        
                        // 현재 타일의 중심점
                        let cx = x + gridSize / 2;
                        let cy = y + gridSize / 2;
                        
                        // 1. 마스킹 체크: 픽셀이 존재하는가?
                        // 캔버스가 600x600이므로 좌표 그대로 가져옴
                        let c = processedImg.get(cx, cy); 
                        let alphaVal = alpha(c); // 투명도 확인
                        
                        // 투명하지 않은 부분(이미지 영역)만 그리기
                        if (alphaVal > 128) {
                            
                            // 2. 왜곡 계산 (Bulge Logic)
                            // 화면 중앙(width/2, height/2)을 기준으로 거리 계산
                            let distFromCenter = dist(cx, cy, width/2, height/2);
                            let maxDist = width / 1.5; // 왜곡이 미치는 범위 조절
                            
                            // 중심에 가까울수록 1, 멀수록 0
                            let factor = map(distFromCenter, 0, maxDist, 1, 0);
                            factor = constrain(factor, 0, 1);
                            
                            // 거듭제곱으로 왜곡을 극대화 (비선형 왜곡)
                            let distortion = pow(factor, bulgeStrength); 
                            
                            // 3. 그리기 (체크보드 패턴)
                            fill(0);
                            noStroke();
                            
                            // 격자 위치 계산 (행, 열)
                            let colIndex = floor(x / gridSize);
                            let rowIndex = floor(y / gridSize);
                            
                            // 왜곡된 크기 적용
                            let currentSize = gridSize * distortion; 
                            
                            // (행+열)이 짝수인 경우에만 검은 사각형 그리기
                            if ((colIndex + rowIndex) % 2 == 0) {
                                rectMode(CENTER);
                                // 크기가 너무 작으면 그리지 않음 (깔끔함 유지)
                                if (currentSize > 0.5) {
                                    rect(cx, cy, currentSize, currentSize);
                                }
                            }
                        }
                    }
                }
                // 한 번만 그리고 멈춤 (CPU 절약)
                noLoop();
            }
        }

        // 파일 처리 함수
        function handleFile(file) {
            if (file.type === 'image') {
                // 이미지 로드
                inputImg = createImg(file.data, '', () => {
                    inputImg.hide(); // HTML 원본 이미지는 숨김
                    
                    // p5 그래픽 버퍼에 이미지 담기 (리사이징)
                    processedImg = createGraphics(width, height);
                    
                    // 업로드된 이미지를 캔버스 크기에 맞게 강제로 늘림 (Fit)
                    // 원본 비율 유지가 필요하면 이 부분을 수정해야 함
                    processedImg.image(inputImg, 0, 0, width, height);
                    
                    loop(); // draw() 함수 다시 실행
                });
            } else {
                inputImg = null;
                alert("이미지 파일만 업로드 가능합니다.");
            }
        }
    </script>
</body>
</html>