<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Op Art Generator V2 - Fix Masking</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #222; /* 배경을 어둡게 해서 캔버스 구분 */
            color: white;
            font-family: sans-serif;
        }
        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            background: white; /* 캔버스 기본 배경 */
        }
        .controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        input[type="file"] { margin-bottom: 10px; }
        .status { color: #ffcc00; font-size: 0.9em; margin-top: 5px; }
    </style>
</head>
<body>

    <div class="controls">
        <p>이미지(검은 물체/흰 배경 또는 투명 배경)를 업로드하세요.</p>
        <div id="status-msg" class="status">대기 중...</div>
    </div>

    <script>
        let inputImg;
        let processedImg;
        let gridSize = 10;      
        let bulgeStrength = 1.8; 

        function setup() {
            let cnv = createCanvas(600, 600);
            cnv.parent(document.body);
            noSmooth();

            let fileInput = createFileInput(handleFile);
            fileInput.parent(select('.controls'));

            // 안내 문구
            background(255);
            fill(0);
            textAlign(CENTER, CENTER);
            textSize(16);
            text("여기에 패턴이 나타납니다.", width/2, height/2);
        }

        function draw() {
            if (processedImg) {
                background(255); // 배경 리셋

                processedImg.loadPixels();
                
                // 픽셀 스캔 시작
                for (let y = 0; y < height; y += gridSize) {
                    for (let x = 0; x < width; x += gridSize) {
                        
                        let cx = x + gridSize / 2;
                        let cy = y + gridSize / 2;

                        // 픽셀 정보 가져오기
                        // 주의: 고해상도 디스플레이(Retina) 대응을 위해 
                        // density를 고려하지 않고 단순화했습니다.
                        let c = processedImg.get(cx, cy);
                        
                        // [핵심 수정 사항]
                        // 1. 투명도(Alpha)가 충분히 높은가? (투명 배경 PNG 대응)
                        // 2. 밝기(Brightness)가 충분히 어두운가? (흰 배경 JPG 대응)
                        // --> 흰색(255)에 가까우면 배경으로 취급하고 무시합니다.
                        
                        let isVisible = alpha(c) > 50 && brightness(c) < 200;

                        if (isVisible) {
                            
                            // === 여기서부터는 아까와 동일한 왜곡 로직 ===
                            let distFromCenter = dist(cx, cy, width/2, height/2);
                            let maxDist = width / 1.5;
                            
                            let factor = map(distFromCenter, 0, maxDist, 1, 0);
                            factor = constrain(factor, 0, 1);
                            let distortion = pow(factor, bulgeStrength); 
                            
                            let currentSize = gridSize * distortion; 
                            
                            let colIndex = floor(x / gridSize);
                            let rowIndex = floor(y / gridSize);
                            
                            fill(0);
                            noStroke();
                            
                            if ((colIndex + rowIndex) % 2 == 0) {
                                rectMode(CENTER);
                                if (currentSize > 0.5) {
                                    rect(cx, cy, currentSize, currentSize);
                                }
                            }
                        }
                    }
                }
                noLoop();
                select('#status-msg').html("생성 완료!");
            }
        }

        function handleFile(file) {
            if (file.type === 'image') {
                select('#status-msg').html("이미지 처리 중...");
                
                inputImg = createImg(file.data, '', () => {
                    inputImg.hide();
                    
                    // 그래픽 버퍼 초기화 (중요: 이전 이미지 잔상 제거)
                    if (processedImg) processedImg.remove();
                    processedImg = createGraphics(width, height);
                    
                    // 1. 버퍼 배경을 투명하게 클리어
                    processedImg.clear();
                    
                    // 2. 이미지를 캔버스 중앙에 '비율 유지하며' 그리기 (Fit)
                    // 이미지가 찌그러지지 않게 계산
                    let imgAspect = inputImg.width / inputImg.height;
                    let canvasAspect = width / height;
                    let drawW, drawH, drawX, drawY;

                    if (imgAspect > canvasAspect) {
                        // 이미지가 더 납작함 -> 가로를 맞춤
                        drawW = width;
                        drawH = width / imgAspect;
                        drawX = 0;
                        drawY = (height - drawH) / 2;
                    } else {
                        // 이미지가 더 길쭉함 -> 세로를 맞춤
                        drawH = height;
                        drawW = height * imgAspect;
                        drawX = (width - drawW) / 2;
                        drawY = 0;
                    }

                    processedImg.image(inputImg, drawX, drawY, drawW, drawH);
                    
                    loop();
                });
            } else {
                inputImg = null;
                alert("이미지가 아닙니다.");
            }
        }
    </script>
</body>
</html>